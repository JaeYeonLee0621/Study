## byte, str, unicode

### python3
- byte : raw 8 bit
- str : unicode 문자 저장

### python2
- str : raw 8 bit
- unicode : unicode 문자 저장

### unicode > binary (raw 8 bit) 
- UTF8 encoding
- 단 python3 str, python2 unicode는 연관된 바이너리 인코딩이 없다 > `encode` `decode` method 사용
- python3
	- bytes > decoding > str
	- str > encoding > bytes


## map, filter 대신에 comprehension 사용
- 나쁜 예
```python
alt = map(lambda x:x**2, filter(lambda x: x%2 == 0, a))
```

```python
alt = [x**2 for x in a if x %2 == 0]
```

> list comprehension 에서 리스트를 2번 쓰면 복잡해진다. 지양하는 것이 좋다.

## iterator 병렬 처리 시 zip을 사용한다
```python
for name, count in zip(names, letters):
	pass
```

## None보다는 예외를 일으키자
```python
def divide(a, b):
	try: 
		return a/b
	except ZeroDivisionError as e:
		raise ValueError('Invalid inputs') from e
```

## list 대신 generator 반환을 고려하자
- Return 값이 크다면
> 단 iterator는 이미 소진한 iterator가 순회하더라도 오류를 일으키지 않는다
```python
if iter(numbers) is iter(numbers):
	raise TypeError('Must supply a container')
```

## `*args` 사용시 주의점
- generator와  *를 함께 사용하면 프로그램이 메모리 부족으로 망가질 수 있다
- `*args` 를 받는 함수에 새 위치 파라미터를 추가하면 정말 찾기 어려운 버그가 될 수 있다

## 키워드 인수를 사용하는 것이 좋다
```python
remainder(numbers=20)
```
- 특히 선택적 인수에는 무조건 키워드 인수를 사용해야 한다

## mixin utility class만 다중 상속을 사용한다
- 인스턴스 수준에서 동작을 교체할 수 있게 만들어 mixin class가 요구할 때 클래스 별로 원하는 동작을 하게 하자
- 간단한 동작들로 복잡한 기능을 생성할 때는 믹스인을 조합하자

## 공개보다는 비공개 속성을 사용하자
```python
class MyObject(object):
	def __init__(self):
		self.__private_field = 10
```
> property, setter, getter를 이용해 변수에 접근할 수 있다

## Custom Container Type을 생성해야하는 경우 collections.abc에 정의된 인터페이스에서 상속받게 하여 필요한 인터페이스 동작과 일치하도록 만들자
- list custom시 collections.abc를 상속하여 기존의 list 기능을 유지

<br/>

# metaclass
- 클래스 위에 클래스가 있음
- Python의 class 문을 가로채서 class가 정의될 때마다 특별한 동작을 제공

## getter와 setter 대신에 일반 속성을 사용하자
- `def get_{}` `def set_{}` 대신에 `@property` `@{property}_setter` 를 이용하자

## getter와 setter를 descriptor로 구현해보자
```python
class Grade(object):
	def __init__(self):
		# self._values = {}
		# __set__ 에 전달된 모든 Exam의 인스턴스 참조를 저장하여 인스턴스 참조 개수가 절대로 0이 되지 않아 Garbage Collector가 정리하지 못한다
		self.values = WeakKeyDictionary()
		# 런타임에서 마지막으로 남은 Exam의 인스턴스 참조를 가지고 있다
		# 모든 Exam 인스턴스가 더는 사용되지 않으면 _values dictionary가 비어있게 된다 

	def __get__(self, instance, type_):
		if not instance: return self
		return self._values.get(instance, 0)

	def __set__(self, instance, value):
		if not (0 <= value <= 100):
			raise ValueError('Grade must be between 0 and 100')
		self._values[instance] = value


class Exame(object):
	math_grade = Grade()
	writing_grade = Garde()
```

## 지연 속성에는 `__getattr__`, `__getattribute__` `__setattr__` 을 사용하자

```python
class LazyDB(object):
	def __init__(self):
		self.exists = 5

	def __getattr__(self, name):
		setattr(self, name, 'value')
```
- 만약 해당 이름이 존재하지 않으면 `__getattr__` 이 실행되고 기본값으로 setting 해준다 

