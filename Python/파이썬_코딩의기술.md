## byte, str, unicode

### python3
- byte : raw 8 bit
- str : unicode 문자 저장

### python2
- str : raw 8 bit
- unicode : unicode 문자 저장

### unicode > binary (raw 8 bit) 
- UTF8 encoding
- 단 python3 str, python2 unicode는 연관된 바이너리 인코딩이 없다 > `encode` `decode` method 사용
- python3
	- bytes > decoding > str
	- str > encoding > bytes


## map, filter 대신에 comprehension 사용
- 나쁜 예
```python
alt = map(lambda x:x**2, filter(lambda x: x%2 == 0, a))
```

```python
alt = [x**2 for x in a if x %2 == 0]
```

> list comprehension 에서 리스트를 2번 쓰면 복잡해진다. 지양하는 것이 좋다.

## iterator 병렬 처리 시 zip을 사용한다

```python
for name, count in zip(names, letters):
	pass
```

## None보다는 예외를 일으키자
```python
def divide(a, b):
	try: 
		return a/b
	except ZeroDivisionError as e:
		raise ValueError('Invalid inputs') from e
```

## list 대신 generator 반환을 고려하자
- Return 값이 크다면
> 단 iterator는 이미 소진한 iterator가 순회하더라도 오류를 일으키지 않는다
```python
if iter(numbers) is iter(numbers):
	raise TypeError('Must supply a container')
```

## `*args` 사용시 주의점
- generator와  *를 함께 사용하면 프로그램이 메모리 부족으로 망가질 수 있다
- `*args` 를 받는 함수에 새 위치 파라미터를 추가하면 정말 찾기 어려운 버그가 될 수 있다

## 키워드 인수를 사용하는 것이 좋다
```python
remainder(numbers=20)
```
- 특히 선택적 인수에는 무조건 키워드 인수를 사용해야 한다

## mixin utility class만 다중 상속을 사용한다
- 인스턴스 수준에서 동작을 교체할 수 있게 만들어 mixin class가 요구할 때 클래스 별로 원하는 동작을 하게 하자
- 간단한 동작들로 복잡한 기능을 생성할 때는 믹스인을 조합하자

## 공개보다는 비공개 속성을 사용하자
```python
class MyObject(object):
	def __init__(self):
		self.__private_field = 10
```
> property, setter, getter를 이용해 변수에 접근할 수 있다

## Custom Container Type을 생성해야하는 경우 collections.abc에 정의된 인터페이스에서 상속받게 하여 필요한 인터페이스 동작과 일치하도록 만들자
- list custom시 collections.abc를 상속하여 기존의 list 기능을 유지

<br/>

# metaclass
- 클래스 위에 클래스가 있음
- Python의 class 문을 가로채서 class가 정의될 때마다 특별한 동작을 제공

## getter와 setter 대신에 일반 속성을 사용하자
- `def get_{}` `def set_{}` 대신에 `@property` `@{property}_setter` 를 이용하자

## getter와 setter를 descriptor로 구현해보자
```python
class Grade(object):
	def __init__(self):
		# self._values = {}
		# __set__ 에 전달된 모든 Exam의 인스턴스 참조를 저장하여 인스턴스 참조 개수가 절대로 0이 되지 않아 Garbage Collector가 정리하지 못한다
		self.values = WeakKeyDictionary()
		# 런타임에서 마지막으로 남은 Exam의 인스턴스 참조를 가지고 있다
		# 모든 Exam 인스턴스가 더는 사용되지 않으면 _values dictionary가 비어있게 된다 

	def __get__(self, instance, type_):
		if not instance: return self
		return self._values.get(instance, 0)

	def __set__(self, instance, value):
		if not (0 <= value <= 100):
			raise ValueError('Grade must be between 0 and 100')
		self._values[instance] = value


class Exame(object):
	math_grade = Grade()
	writing_grade = Garde()
```

## MetaClass로 SubClass를 검증한다

```python
class ValidatePloygen(type):
	def __new__(meta, name, bases, class_dict):
		if base != (object,):
			if class_dict['sides'] < 3:
				raise ValueError('Polygons need 3+ sides')
		return type.__new__(meta, name, bases, class_dict)

class Polygon(object, metaclass=ValidatePloygen):
	sides = None

	@classmethod
	def interior_angles(cls):
		return (cls.sides - 2) * 180
```
- 3개 미만인 다각형을 정의하려고 하면 검증 코드가 class 문의 본문이 끝나자마자 class 문을 실패하게 만듬

## Class에서 무조건 실행하게 만드려면 Meta Class를 사용한다

```python
class Meta(type):
	def __new__(meta, name, bases, class_dict):
		cls = type.__new__(meta, name, bases, class_dict)
		# add def must be executed
		return cls
```

## Meta Class로 중복을 제거한다
- 변경 전
```python
class Customer(object):
	first_name = Field('first_name') # 이름에 중복이 있음
```

- 변경 후
```python
class Meta(type):
	def __new__(meta, name, bases, class_dict):
		for key, value in class_dict.items():
			if isinstance(value, Field):
				value.name = key
				value.internal_name = '_' + key
			cls = type.__new__(meta, name, bases, class_dict)
			return cls

class Customer(object):
	first_name = Field()
```

# 병행성 & 병렬성
- 병행성 : 프로세스를 교대로 실행하여 마치 동시에 실행하는 것처럼 보이게 만듬
- 병렬성 : 실제로 여러 작업을 동시에 실행

## Thread는 Blocking I/O 용으로는 사용하고 병렬화용으로는 사용하지 말자
- GIL은 한 번에 한개의 Thread만 실행하게 하여 Thread 병렬 연산 혹은 파이썬 프로그램 속도를 높일 때는 성능이 
- 그럼 왜 Thread를 만들었어?
	1. 프로그램이 동시에 여러 작업을 하는 것처럼 만들기 쉽다
		- GIL로 인하여 한 번에 한 Thread만을 실행하지만, CPython은 Python Thread가 어느 정도 공평하게 실행됨을 보장한다
	2. Blocking I/O
		- 프로그램에서 외부 환경과 상호작용하도록 하는 작업 시 이런 프로그램과 이런 요청에 응답하는 데 드는 시간을 분리하므로 처리에 용이

## Thread의 Lock
- GIL은 프로그램 자료구조에 잠금을 시키지 않는다
- 따라서 두 바이트코드 명령어 사이에 인터럽트될 수 있다

```python
class LockingCounter(object):
	def __init__(self):
		self.lock = Lock()
		self.count = 0

	def increment(self, offset):
		with self.lock:
			self.count += offset

counter = LockingCounter()
run_thread(worker, how_many, counter)
```

## 많은 함수를 동시에 실행하려면 코루틴을 고려하자
- generator corroutine을 한 번 활성화되서 소진할 때까지 1KB 미만의 메모리만을 소비한다
- 프로그램의 핵심 로직을 주변 환경과 상호 작용하는 코드로부터 분리할 수 있는 강력한 도구
```python
def minimize():
	current = yield

	while True:
		value = yield current
		current = min(value, current)

it = minimize()
it.send(10) # 10
it.send(4) # 4
it.send(22) # 4
it.send(-1) # -1
```

## 진정한 병렬성을 실현하려면 concurrent.futures를 고려하자
- multi processing을 사용하도록 함
- Python에서 multi threading을 지원하지 않기 때문에 여러 Thread를 실행하는 것이 더 느린 연산을 하게 만든다
- 하지만 Multi Processing은 지원하기 때문에 Multi Processing의 속도가 훨씬 빠르다

# 내장 함수

## functools.wraps로 함수 decorator를 정의한다 
- decorator : 런타임에 한 함수로 다른 함수를 수정할 수 있게 해주는 파이썬 문법
- 변경전
	- 아래와 같이 구현하면, 객체 내부를 조사하는 도구를 사용할 때 문제가 될 수 있다
```python
def trace(func):
	def wrapper(*args, **kwargs):
		result = func(*args, **kwargs)
		print('decorator')
		return result
	return wrpper

def fibonacci(n):
	if n in (0, 1): return n
	return (fibonacci(n-2) + fibonacci(n-1))

fibonacci = trace(fibonacci)
```

- 변경후
	- 아래와 같이 구현하면 객체 내부를 조사하는 도구를 사용할 때 문제가 되지 않는다
```python
def trace(func):
	@wrap(func)
	def wrapper(*args, **kwargs):
		result = func(*args, **kwargs)
		print('decorator')
		return result
	return wrpper

@trace
def fibonacci(n):
	if n in (0, 1): return n
	return (fibonacci(n-2) + fibonacci(n-1))
```

## 재사용 가능한 try/finally 동작을 만들려면 contextlib와 with문을 고려한다
- try/finally 보다는 with 문이 낫다
```python
def my_function():
	logging.debug('1')
	logging.error('2') # 원래는 이것만 출력

@contextmanage
def debug_logging(level):
	logger = logging.getLogger()
	logger.setLevel(level)
	old_level = logger.getEffectiveLevel()
	try:
		yield # with block이 실행되고 with안에서 일어난 Exception까지 여기서 처리한다
	finally:
		logger.setLevel(old_level)

with debug_logging(logging.DEBUG):
	my_function() # 1 이 출력
```

- class로 넘길 수 있음
```python
@contextmanage
def debug_logging(level):
	logger = logging.getLogger()
	logger.setLevel(level)
	old_level = logger.getEffectiveLevel()
	try:
		yield logger
	finally:
		logger.setLevel(old_level)

with debug_logging(logging.DEBUG) as logger:
	logger.debug('1')
	logger.error('2')
```